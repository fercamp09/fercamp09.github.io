
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Mi primer objeto inteligente con IoTivity</title>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Mi primer objeto inteligente con IoTivity"
                  environment="web"
                  feedback-link="https://github.com/googlecodelabs/iotivity-first-device/issues">
    
      <google-codelab-step label="Introducción" duration="5">
        <p>Este Codelab lo guiará en la creación de sus propios objetos inteligentes con IoTivity. </p>
<ul>
<li><strong>Objeto inteligente</strong>: es un objeto cotidiano con capacidad de procesamiento y comunicación. </li>
<li><strong>IoTivity:</strong> es un proyecto de código abierto que implementa el estándar de la Open Connectivity Foundation (OCF) para la comunicación entre objetos inteligentes independiente del protocolo.</li>
</ul>
<p>Se lo guiará con la compilación de IoTivity, la configuración de los dispositivos y la ejecución de los mismos, para asegurar que su primera experiencia con IoTivity sea enriquecedora y que cumpla con los lineamientos propuestos por la OCF. </p>
<h2>¿Qué construirás<strong>?</strong></h2>
<table>
<tr><td colspan="1" rowspan="1"><p>En este codelab, usted construirá un interruptor y una luz que integren IoTivity.</p>
<p>Su foquito va a:</p>
<ul>
<li>Ejecutarse en un Raspberry Pi.</li>
<li>Ser escrito en C++.</li>
<li>Apagarse y encenderse remotamente por otro dispositivo de iotivity.</li>
<li>Comunicarse de manera segura.</li>
</ul>
<p>Su interruptor va a:</p>
<ul>
<li>Ejecutarse en un celular Android o una PC.</li>
<li>(Opcional) Ser escrito en Node.js y operado mediante una interfaz gráfica.</li>
<li>Utilizar y demostrar las capacidades básicas de Iotivity.</li>
<li>Encender y apagar un LED remotamente.</li>
<li>Comunicarse de manera segura.</li>
</ul>
</td><td colspan="1" rowspan="1"><p><img style="max-width: 298.00px" src="img\a8d698ba510a237a.png"></p>
</td></tr>
</table>
<h2><strong>¿Qué aprenderás?</strong></h2>
<ul>
<li>Cómo instalar y probar que IoTivity está correctamente instalado.</li>
<li>Cómo escribir y compilar un programa en C++ para crear tu propio dispositivo inteligente de IoTivity.</li>
<li>Cómo adueñar y aprovisionar dispositivos de IoTivity.</li>
</ul>
<h2>¿Qué necesitarás?</h2>
<p>1 <strong>Raspberry Pi </strong>con<strong>:</strong></p>
<ul>
<li><strong>Sistema Operativo (OS): </strong>Raspbian Stretch Lite</li>
<li>Fuente de poder </li>
<li>Tarjeta SD</li>
<li>USB micro SD lector de tarjetas</li>
</ul>
<p>Elementos de electrónica: </p>
<ul>
<li>1 LED</li>
<li>2 cables (jumpers)</li>
<li>1 protoboard</li>
</ul>
<p>        1 computador con <strong>Ubuntu 16.04</strong> o superior.</p>
<p>1 editor de texto (en este tutorial la edición de texto se realiza con <code>nano</code> por defecto, si tiene uno de preferencia puede reemplazarlo en los comandos por <code>nano</code>)</p>
<p>Conocimiento básico de <strong>C++, JavaScript, shell</strong>.</p>
<p>Si la red no soporta <strong>Multicast</strong>: configurar una red WPA2 usando un router adicional.</p>
<p><img style="max-width: 624.00px" src="img\cb75007a09b21a6f.png"></p>
<p>Este Codelab está enfocado en IoTivity. Los conceptos no relevantes y bloques de código son provistos. </p>
<p><code>ctrl + c</code> para copiar</p>
<p><code>ctrl + shift + v</code> para pegar o clic derecho y pegar.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Información de apoyo" duration="4">
        <p>Vamos a conectar dos objetos inteligentes, pero ustedes se preguntarán:</p>
<h2><strong>¿Qué es un objeto inteligente?</strong></h2>
<p>Un objeto inteligente es un objeto cotidiano con capacidad de procesamiento y comunicación. Puede comunicarse con otros objetos de manera autónoma o interactuar con el usuario mediante una interfaz.</p>
<p>Y la conexión se realizará con IoTivity, lo que nos lleva a preguntarnos:</p>
<h2><strong>¿Qué es Iotivity?</strong></h2>
<p>Iotivity es un proyecto de código abierto que implementa el <strong>estándar de la Open Connectivity Foundation (OCF)</strong> para la comunicación entre objetos inteligentes independiente del protocolo. El estándar cuenta con <strong>versión 2.0</strong>, disponible en este <a href="https://openconnectivity.org/developer/specifications" target="_blank">enlace</a>. La especificación se basa en una arquitectura <strong>REST</strong>, en la que existe un cliente que puede descubrir e interactuar con recursos en el servidor. En nuestro caso el servidor será un foquito y el cliente será el interruptor virtual o un celular.  Definidos por la OCF como:</p>
<ul>
<li><strong>Cliente OCF (OCF Client):</strong> Es una entidad lógica que interactúa con recursos de un servidor OCF mediante descubrimiento de los mismos y posterior acceso con operaciones CRUDN (C: Create / Crear , R: Retrieve / Obtener, U: Update / Actualizar, D: Delete / Eliminar, N: Notify / Notificar)</li>
<li><strong>Servidor OCF (OCF Server):</strong> Es una entidad lógica que expone sus recursos almacenados, se puede descubrir y responde a las transacciones iniciadas por un cliente.</li>
</ul>
<p>Un dispositivo OCF puede tener uno o ambos roles.</p>
<p><img style="max-width: 624.00px" src="img\9dde3a15a74215e0.png"></p>
<p>Tomado de <a href="https://openconnectivity.org/wp-content/uploads/2018/06/2.-OCF-Architecture-Introduction.pdf" target="_blank">OCF Specification Overview Core Technology Specification</a></p>
<p>Un <strong>Servidor OCF</strong> contiene uno o más recursos para describir el mundo real. Cada recurso contiene <strong>propiedades</strong> que describen un aspecto del recurso, algunas son opcionales y dependen del recurso, y otras son mandatorias para todos como las siguientes:</p>
<ul>
<li><strong>Interfaces</strong> (&#34;if&#34; que significa &#34;interface&#34;) que proveen una previa del recurso y luego definen las respuestas y peticiones permitidas para ese recurso. </li>
<li><strong>Tipo </strong>(rt que significa &#34;resource type&#34;) que permite conocer las propiedades que debe poseer ese tipo de recurso.</li>
</ul>
<p>IoTivity busca lograr:</p>
<ul>
<li><strong>Interoperabilidad -</strong> Se basa en el acceso de recursos mediante una REST API, y los modelos de los dispositivos están definidos en la página de <a href="https://oneiota.org/" target="_blank">OneIOTA</a> de manera estándar. </li>
<li><strong>Seguridad</strong> - Protege la integridad, confidencialidad y evita el reenvío de datos (DTLS). Por medio de mecanismos de control de acceso (ACL: Access Control List), encriptación de datos (AES-128, SHA-256). Los dispositivos deben autenticarse para comunicarse por unicast, para lo cual deben poseer las claves de seguridad elegidas. La comunicación multicast no es segura, es anónima y visible.    </li>
<li><strong>Comunicación</strong> - La comunicación de los datos es transparente sin importar el protocolo. Aunque por el momento solo COAP sobre UDP está soportada. En el futuro se planea integrar Bluetooth. Existe una comunicación de COAP sobre TCP para comunicarse por internet que se lo usa en iotivity-cloud. IoTivity Cloud busca acceder a los recursos mediante Internet. </li>
</ul>
<aside class="special"><p>¿Quieres saber más? Puedes revisar las <a href="https://openconnectivity.org/developer/specifications" target="_blank">especificaciones de la OCF</a>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Configurar Raspberry Pi" duration="6">
        <p>En este Tutorial vamos a crear una luz inteligente, compuesta por un Raspberry Pi y elementos electrónicos. </p>
<p>El Raspberry Pi es una computadora de bajo costo del tamaño de una tarjeta de crédito, que puede usarse con un monitor por HDMI o aparte a través de conexión de red. Es capaz de hacer todo lo que una computadora puede, pero lo que lo hace especial es la habilidad de interactuar con el mundo exterior por medio de pines llamados GPIO, a los que se le puede conectar sensores o actuadores y usar protocolos como SPI, UART, entre otros. La desventaja es que estos pines son digitales y para conectar un sensor análogico se debe usar un convertidor análogico a digital (ADC: Analog to Digital converter). En la siguiente imagen se muestran los pines como referencia:</p>
<p><img style="max-width: 437.60px" src="img\fadcce31495a5c45.png"></p>
<p>Nombres de pines del Raspberry Pi. Tomado de www.element14.com.</p>
<p>Conectar los elementos electrónicos como se muestra en la siguiente imagen (GPIO11, PIN23):</p>
<p><img style="max-width: 624.00px" src="img\3a4cb19db20e4e2d.png"></p>
<p>El Raspberry Pi siendo una computadora necesita de un sistema operativo sobre el cual ejecutar programas. La lógica de nuestro foquito será escrita en un programa C++ que se ejecutará dentro del Raspberry Pi. Existen varias opciones de sistemas operativos para Raspberry Pi, pero usaremos la oficial, llamada <strong>Raspbian</strong>. En nuestro caso usaremos la versión <strong>Raspbian Stretch Lite</strong>, que viene sin interfaz gráfica.</p>
<aside class="special"><p>La información que esté precedida por un &#34;$&#34; se ejecuta dentro de un terminal, pueden copiar los comandos omitiendo el &#34;$&#34;.</p>
</aside>
<h2><strong>Instalar Raspbian</strong></h2>
<ol type="1" start="1">
<li>Descargar <a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank">Raspbian Stretch Lite</a> </li>
</ol>
<p><a href="https://downloads.raspberrypi.org/raspbian_lite_latest" target="_blank"><paper-button class="colored" raised>Descargar .ZIP</paper-button></a></p>
<ol type="1" start="2">
<li>Instalar <a href="http://etcher.io" target="_blank">Etcher</a> (Windows o Linux)</li>
<li>Usar <strong>Etcher </strong>para quemar la imagen de <strong>Raspbian</strong> a la <strong>tarjeta SD</strong>. Para esto Insertamos la tarjeta SD a la PC. Ejecutamos <strong>Etcher </strong>y seleccionamos el volumen de la tarjeta SD insertada, por lo general se selecciona automáticamente. A continuación procedemos a quemar, con el botón respectivo. </li>
<li>Activar el <code>ssh</code> en el <strong>Raspberry Pi</strong>: crear un archivo en <strong>/boot</strong> llamado <em>&#34;ssh&#34;</em> no <em>&#34;ssh.txt&#34;</em>. Puede abrir un terminal y ejecutar lo siguiente, cambiando el <code>[path-to-volume]</code> por su nombre de tarjeta SD:</li>
</ol>
<pre><code>$ cd [path-to-volume]/boot
$ touch ssh # touch sirve para crear archivos</code></pre>
<ol type="1" start="5">
<li>Activar el <strong>Wi-Fi</strong>, para lo cual creamos un archivo con la configuración de la red (ssid y clave). </li>
</ol>
<pre><code># nano también crea archivos pero al crearlos permite editarlos
$ nano wpa_supplicant.conf </code></pre>
<h2><strong>Configurar red</strong></h2>
<p>Si recién se quemo la tarjeta. Esto se escribe dentro del archivo <code>wpa_supplicant.conf</code> en el /boot, reemplazando <strong>&#34;Your network SSID&#34;</strong> y <strong>&#34;Your WPA/WPA2 security key&#34;</strong> con el ssid y clave de su red<code>:</code>:</p>
<p><strong>wpa_supplicant.conf</strong></p>
<pre><code>ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=US

network={
        ssid=&#34;Your network SSID&#34;
        psk=&#34;Your WPA/WPA2 security key&#34;
        key_mgmt=WPA-PSK
}</code></pre>
<p><code>ctrl + x</code> para salir y guardar</p>
<p>Si ya se usó la tarjeta con un Raspberry Pi, editar desde la pc:.</p>
<pre><code>$ sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</code></pre>
<h2><strong>Habilitar UART</strong></h2>
<p>Para habilitar uart, editamos config.txt:</p>
<pre><code>$ nano config.txt</code></pre>
<p>Y agregamos la siguiente línea al final::</p>
<p><strong>wpa_supplicant.conf</strong></p>
<pre><code>`enable_uart=1` to config.txt.</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Preparar el ambiente de IoTivity" duration="10">
        <p>IoTivity puede compilarse en Windows, Ubuntu, Raspbian entre otros sistemas operativos. Nos enfocamos en los más accesibles y con mayor soporte, los cuales usaremos en nuestro proyecto: <strong>Ubuntu</strong> y <strong>Raspberry Pi</strong>. Adicionalmente mostramos la instalación en <strong>CentOS</strong>, por si desean instalarlo en un servidor. </p>
<aside class="special"><p>La información que esté precedida por un &#34;$&#34; se ejecuta dentro de un terminal, pueden copiar los comandos omitiendo el &#34;$&#34;.</p>
</aside>
<h2><strong>Instalar dependencias en Raspberry Pi</strong></h2>
<p>4.1 Este paso asume que el <strong>Raspberry Pi </strong>ya está configurado con red y ssh. Para conectarse con el <strong>Raspberry Pi </strong>por ssh a través de la red, ejecutamos desde un terminal los siguientes comandos:</p>
<aside class="special"><p> Cambiar el <code>1</code> en <code>raspberrypi1</code> por el número que le tocó, ejemplo <code>raspberrypi2</code>:</p>
</aside>
<pre><code>$ ping raspberrypi2.local
$ ssh pi@raspberrypi2.local
user: pi
passwd: raspberry
$ passwd  # para cambiar el password</code></pre>
<p>Estas instrucciones de instalación han sido probadas en <strong>Raspbian Stretch Lite</strong>.</p>
<p>4.2 Actualizar paquetes (Buscar actualizaciones disponibles y luego instalar):</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get -qy upgrade</code></pre>
<p>4.3 Instalar los paquetes:</p>
<pre><code>$ sudo apt-get -qy install build-essential git scons libtool \
autoconf valgrind doxygen wget unzip cmake libboost-dev \
libboost-program-options-dev libboost-thread-dev uuid-dev \
libexpat1-dev libglib2.0-dev libsqlite3-dev libcurl4-gnutls-dev</code></pre>
<p><strong>MRAA</strong></p>
<p>MRAA es una librería escrita en C con bindings para C++, Java, Python y Node.js (Javascript) que permite acceder a sensores y actuadores a través de una variedad de plataformas de hardware. La usaremos en nuestro proyecto para acceder al pin del Raspberry Pi donde se conectará el foquito, y enviarle una señal de Alto o Bajo.</p>
<p>4.5 Descargar <code>mraa</code> dentro de la carpeta <code>iot</code>, ejecutar lo siguiente en un terminal:</p>
<pre><code>$ mkdir ~/iot
$ cd ~/iot
$ git clone https://github.com/intel-iot-devkit/mraa.git </code></pre>
<p>4.6 Compilar <code>mraa</code>:</p>
<pre><code>$ mkdir mraa/build &amp;&amp; cd mraa/build
$ cmake .. &amp;&amp; make &amp;&amp; sudo make install </code></pre>
<p>4.7 Probar que <code>mraa</code> funciona, ejecutando un ejemplo de encender un <strong>LED</strong>:</p>
<pre><code>$ cd ~/iot/mraa/build/examples/c++ &amp;&amp; sudo ./gpio_cpp 23 #7</code></pre>
<p>Si todo sale bien, el <strong>LED </strong>colocado al <strong>Raspberry Pi</strong> debería encenderse y apagarse.</p>
<p>A continuación debemos configurar el mismo ambiente en la PC con Ubuntu, que contendrá nuestro interruptor virtual:</p>
<h2><strong>Instalar dependencias en Linux</strong></h2>
<h3><strong>Ubuntu</strong></h3>
<p>Estas instrucciones de instalación han sido probadas en<strong> Ubuntu 16.04 LTS</strong>.</p>
<aside class="special"><h3><strong>Comandos intercambiables (Ubuntu)</strong></h3>
<p><strong>apt-get:</strong> antigua sintaxis </p>
<p><code>apt-get update  </code></p>
<p><strong>apt:</strong> nueva sintaxis</p>
<p><code>apt update  </code></p>
<p>Se puede usar la que deseen.</p>
</aside>
<p>4.8 Actualizar paquetes (Buscar actualizaciones disponibles y luego instalar):</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get -qy upgrade</code></pre>
<p>4.9 Instalar herramientas de compilación:</p>
<pre><code>$ sudo apt-get -qy install \
 build-essential git scons ssh valgrind doxygen wget chrpath \
 libtool autoconf pkg-config unzip gcovr  </code></pre>
<p>4.10 Instalar soporte de desarrollo para librerías externas:</p>
<pre><code>$ sudo apt-get -qy install libboost-all-dev libsqlite3-dev uuid-dev libexpat1-dev libglib2.0-dev libcurl4-gnutls-dev libbz2-dev </code></pre>
<aside class="special"><p><code>libboost-all-dev</code> contiene <code>libboost-dev, libboost-program-options-dev, libboost-thread-dev</code> y muchas más. Pueden reemplazar <code>libboost-all-dev</code> por esas tres, para evitar instalar librerias innecesarias.</p>
</aside>
<p>4.11 Crear una carpeta para almacenar los proyectos de <code>IoT</code>:</p>
<pre><code>$ mkdir ~/iot
$ cd ~/iot</code></pre>
<aside class="special"><p>Está listo para continuar al siguiente paso, en el que se instalará IoTivity.</p>
</aside>
<p>4.12 Si desea instalar soporte para Android:</p>
<pre><code>$ sudo apt-get -qy install openjdk-8-jdk icedtea-plugin</code></pre>
<h3><strong>CentOS </strong></h3>
<p>Estas instrucciones de instalación han sido probadas en <strong>CentOS 7</strong>.</p>
<p>4.13 Agregar repositorios adicionales para paquetes de <strong>CentOS7 64 bit</strong>:</p>
<pre><code>// Alternativa 1 (Instalada en el servidor)
sudo rpm -i http://cbs.centos.org/kojifiles/packages/scons/2.5.1/4.el7/noarch/scons-2.5.1-4.el7.noarch.rpm
// Alternativa 2
sudo rpm -i tools/tizen/scons-2.1.0-3.1.slp.noarch.rpm
// Alternativa 3
$ sudo yum install epel-release
$ sudo rpm -ivh http://repo.okay.com.mx/centos/7/x86_64/release/okay-release-1-1.noarch.rpm</code></pre>
<p>4.14 Actualizar repositorios:</p>
<pre><code>$ sudo yum update</code></pre>
<p>4.15 Instalar dependencias:</p>
<pre><code>$ sudo yum install \
      expat-devel  libcurl-devel  openssl-devel \
      boost-devel  boost-thread boost-filesystem \
      glib2-devel  sqlite-devel  libuuid-devel \
      boost-program-options libsqlite3x-devel \
      perl-CBOR-XS wget unzip \
      gcc gcc-c++ scons \
      autoconf make automake \
      git libtool valgrind doxygen</code></pre>
<aside class="special"><h3><strong>Diferencia con Ubuntu</strong></h3>
<p>Instalar <code>libuuid-devel</code> en vez de <code>uuid-devel</code>.</p>
</aside>
<p>4.16 Permitir tráfico de mensajes udp a través del firewall:</p>
<pre><code>$ sudo firewall-cmd --permanent --add-protocol=udp
$ sudo firewall-cmd reload</code></pre>
<p>4.17 Crear una carpeta para almacenar los proyectos de <code>IoT</code>:</p>
<pre><code>$ mkdir ~/iot
$ cd ~/iot</code></pre>
<aside class="special"><p>De este punto en adelante, todo debe hacerse con la configuración elegida.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Instalar IoTivity (Ubuntu y Raspberry Pi)" duration="45">
        <p>IoTivity es un proyecto open-source y como tal su código se encuentra disponible en Github para descargarlo fácilmente. </p>
<p>5.1 Clonar el repositorio de IoTivity en la carpeta <code>iot</code> (está carpeta fue creada en el paso anterior), en un terminal ejecutar:</p>
<pre><code>$ cd ~/iot
$ git clone https://github.com/iotivity/iotivity.git
$ cd ~/iot/iotivity</code></pre>
<p>5.2 Ejecutar:</p>
<pre><code>$ scons examples/OCFSecure -j 2 TARGET_TRANSPORT=IP</code></pre>
<p>5.3 Se muestra un mensaje que dice que clonemos unos repositorios, primero de <code>mbedtls-2.4.2</code> y luego <code>tinycbor</code>. Podemos evitar estos mensajes ejecutando los comandos solicitados antes de ejecutar <code>scons</code>:</p>
<pre><code>$ git clone https://github.com/ARMmbed/mbedtls.git extlibs/mbedtls/mbedtls -b mbedtls-2.4.2
$ git clone https://github.com/intel/tinycbor.git extlibs/tinycbor/tinycbor -b v0.5.1</code></pre>
<h2>¿Qué es <code>scons</code><strong> y cómo funciona?</strong></h2>
<p><code>scons</code> es una herramienta de construcción de software parecido a <code>make</code>, pero que se escribe en python, lo que nos brinda todas las ventajas de un lenguaje de programación real para construir nuestros proyectos. </p>
<p><code>scons</code> busca por defecto un archivo <strong>SConstruct</strong>, que a su vez puede llamar a archivos de configuración conocidos como <strong>SConscript. </strong>Estos archivos<strong> SConscript </strong>puede nombrarse como gusten, mientras sea registrado con la función SConscript en algún archivo de configuración como lo muestra el siguiente extracto:</p>
<pre><code># Load common build config
SConscript(&#39;build_common/SConscript&#39;)
# Load extra options 
SConscript(&#39;extra_options.scons&#39;) </code></pre>
<p>Estos archivos de configuración contienen los archivos a ser construidos (targets) y opcionalmente las reglas para construirlos. <code>scons</code> lee y ejecuta los archivos <strong>SConscript</strong> como scripts de Python, pudiendo utilizar las capacidades de Python (como control de flujo, manipulación de datos, e importar librerías).</p>
<p>De vuelta a la acción: </p>
<p>5.4 En el<strong> Raspberry Pi</strong> hay que editar el<strong> SConscript</strong> para indicarle el <strong>pin</strong> que vamos a usar con nuestro <strong>LED</strong>, editamos el archivo con <code>nano</code>:</p>
<pre><code>$ nano ~/iot/iotivity/examples/OCFSecure/SConscript</code></pre>
<p>En la línea 85, cambiamos el <code>7</code> por <code>23</code>:</p>
<aside class="special"><p>Para ir a la línea en <code>nano</code>: <code>ctrl + _</code>  luego ingresar el número de línea y <code>enter</code>.</p>
</aside>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80" target="_blank"><strong>examples/OCFSecure</strong></a><strong>/SConscript</strong></p>
<pre><code>elif not joule and raspberry_pi: cpp_defines.append(&#39;LED_PIN=23&#39;) # antes &#39;LED_PIN=7&#39;</code></pre>
<p><code>ctrl + x</code> para guardar</p>
<p>5.5 Para ejecutar <code>scons</code><strong> </strong>hay que colocarnos en la carpeta que contiene el <strong>SConstruct</strong>. Nos cambiamos a ese directorio (<code>~/iot/iotivity</code>) y compilamos <strong>IoTivity</strong> en el <strong>Raspberry Pi </strong>y realizamos lo mismo en<strong> Ubuntu</strong>:</p>
<pre><code># Ubuntu
$ cd ~/iot/iotivity
$ scons examples/OCFSecure -j 2 TARGET_TRANSPORT=IP
# Raspberry Pi
$ cd ~/iot/iotivity
$ scons examples/OCFSecure -j 2 TARGET_TRANSPORT=IP
scons: done building targets.</code></pre>
<p>-j: parámetro de scons para construir en paralelo. </p>
<p>El comando ejecutado compila los archivos de la carpeta <code>examples/OCFSecure</code> que están definidos en el <strong>SConscript </strong>de esa carpeta y es referenciado en el <strong>SConstruct </strong>del directorio root del proyecto (<code>~/iot/iotivity</code>). </p>
<p>Si la compilación es exitosa, deberíamos ver un mensaje al final que diga: </p>
<pre><code>scons: done building targets.</code></pre>
<aside class="special"><p>Puede continuar al siguiente paso, donde se explica el código del foquito.</p>
</aside>
<p>IoTivity viene configurado por defecto con seguridad, si se la desea desactivar hay que agregar el parámetro SECURED=0. Esto es útil si se quiere hacer un prototipo rápido. El comando a ejecutar sería:</p>
<pre><code>$ scons examples/OCFSecure -j 2 TARGET_TRANSPORT=IP SECURED=0</code></pre>
<aside class="special"><p>Ayuda adicional: <a href="https://wiki.iotivity.org/getting_started_troubleshooting_and_faq" target="_blank">Resolución de problemas</a></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Cómo funciona el foquito en el Raspberry Pi" duration="11">
        <p>Un dispositivo IoTivity contiene los siguientes recursos:</p>
<ul>
<li><strong>/oic/p: </strong>La p es de &#34;platform&#34;, contiene propiedades sobre el hardware, como fabricante o nombre (n). Si hay dos dispositivos en el mismo hardware, este recurso será idéntico para ambos.</li>
<li><strong>/oic/d: </strong>La d es por &#34;device&#34;, contiene propiedades del dispositivo como el uuid, di (device id).</li>
<li><strong>/oic/res: </strong>res de &#34;resource&#34;,  es el recurso al cual se realiza la petición de descubrimiento (Multicast RETRIEVE (CoAP GET)) que muestra la información relacionada a los otros recursos disponibles.</li>
</ul>
<p><img style="max-width: 624.00px" src="img\6f7cc95255489cf1.png"></p>
<p>Tomado de <a href="https://openconnectivity.org/wp-content/uploads/2018/06/2.-OCF-Architecture-Introduction.pdf" target="_blank">OCF Specification Overview Core Technology Specification</a></p>
<p>La comunicación se realiza a través de <strong>CoAP</strong> (Constrained Application Protocol) que es un protocolo REST parecido a HTTP pero reducido. Los mensajes son serializados en formato <strong>CBOR</strong> (Concise Binary Object Representation) que es un formato binario reducido parecido a JSON.</p>
<p><img style="max-width: 407.50px" src="img\6091743af651726c.png"></p>
<p>Tomado de <a href="https://openconnectivity.org/wp-content/uploads/2018/06/2.-OCF-Architecture-Introduction.pdf" target="_blank">OCF Specification Overview Core Technology Specification</a></p>
<p>Existen ciertos recursos que son <strong>mandatorios</strong>, por ejemplo los recursos esenciales de platform, device y /oic/res. En la siguiente imagen, vemos que hay un luz inteligente (oic.d.light), que se puede representar con dos recursos extras de los cuales uno es mandatorio que es <strong>oic.r.switch.binary</strong> el cual permite encender o apagar la luz y es fundamental para toda luz, en cambio <strong>oic.r.light.brightness</strong> es opcional ya que no todas las luces cuentan con ajuste de intensidad. Para nuestro ejemplo solo necesitamos encender y apagar la luz y usaremos <strong>oic.r.switch.binary</strong> . </p>
<p><img style="max-width: 624.00px" src="img\f453fc5a05041414.png"></p>
<p>Tomado de <a href="https://openconnectivity.org/wp-content/uploads/2018/06/2.-OCF-Architecture-Introduction.pdf" target="_blank">OCF Specification Overview Core Technology Specification</a></p>
<p>6.0 Opcionalmente podemos inspeccionar el código, ejecutando en un terminal lo siguiente:</p>
<pre><code>$ cd ~/iot/iotivity/examples
$ nano server.cpp</code></pre>
<aside class="special"><p>Para ir a la línea en <code>nano: ctrl + _</code>  luego ingresar el número de línea y <code>enter</code>.</p>
</aside>
<p>6.1 Los objetos se acceden por medio de uris, pero están definidos lógicamente como clases o estructuras en el código. En la línea 47, se define una estructura para representar a la luz, se llama <strong>switch </strong>porque es el interruptor interno de encendido y apagado del foquito. Vemos que cuenta con las propiedades de <code>OC_DISCOVERABLE | OC_SECURE,</code> para poder ser descubierto y comunicarse de manera segura. Se define el tipo como <code>oic.r.switch.binary</code>, la interfaz de actuador es <code>oic.if.a</code>, el <code>uri</code> para realizar las peticiones será <code>&#34;/switch&#34; y</code> contiene una propiedad booleana <strong>value</strong>, que representará el estado de encendido de la luz, con verdadero o falso.</p>
<p><strong>examples/OCFSecure/server.cpp </strong></p>
<pre><code>typedef struct
{
        OCResourceHandle handle;
        const char* type = &#34;oic.r.switch.binary&#34;;
        const char * interface = OC_RSRVD_INTERFACE_ACTUATOR;
        const char* uri = &#34;/switch&#34;;
        uint8_t properties = OC_DISCOVERABLE | OC_SECURE;
        bool value = false;

} BinarySwitch;</code></pre>
<p>A continuación hay unas funciones decorativas para agregar información de Plataforma y de Dispositivo como lo son <code>SetPlatformInfo</code> y <code>SetDeviceInfo</code> respectivamente.</p>
<p>6.2 Cuando se hace un requerimiento al servidor, se espera una respuesta, esta respuesta viene con un payload. En la línea 203, se encuentra la función encargada de crear el payload de la respuesta del requerimiento. Se crea un payload con <code>OCRepPayloadCreate</code> y se le agrega información adicional con <code>OCRepPayloadAdd[tipo-de-recurso]</code>, por ejemplo si se quiere agregar una propiedad booleana se utiliza  <code>OCRepPayloadSetPropBool,</code> y se coloca el nombre y valor de  la propiedad.</p>
<p><strong>examples/OCFSecure/server.cpp </strong></p>
<pre><code>OCRepPayload*
CreateResponsePayload(BinarySwitch resource)
{
        OCRepPayload* payload = OCRepPayloadCreate();
     [...]
     OCRepPayloadAddInterface(payload, OC_RSRVD_INTERFACE_DEFAULT);
        OCRepPayloadAddInterface(payload, resource.interface);
        OCRepPayloadAddResourceType(payload, resource.type);
        OCRepPayloadSetPropBool(payload, &#34;value&#34;, resource.value);

        return payload;
}</code></pre>
<p>6.3 En la línea 231, se define la función <code>ProcessGetRequest</code> que se encargará de manejar  una petición <strong>GET (RETRIEVE)</strong>. Lo que hace es crear un payload con la información del interruptor del foquito, dicha información es una variable global SWITCH definida en la línea 54. Si se crea correctamente retorna <code>OC_EH_OK</code>, sino retorna <code>OC_EH_ERROR.</code></p>
<p><strong>examples/OCFSecure/server.cpp </strong></p>
<pre><code>static BinarySwitch SWITCH;

OCEntityHandlerResult ProcessGetRequest(OCRepPayload **payload)
{
        OCEntityHandlerResult eh_res = OC_EH_ERROR;

        OCRepPayload *ResponsePayload = CreateResponsePayload(SWITCH);

        if (ResponsePayload)
        {
            *payload = ResponsePayload;
            eh_res = OC_EH_OK;
        }

        return eh_res;
}</code></pre>
<p>6.4 Así como se creó un <strong>GET</strong> para obtener el estado del foquito, se creará un <strong>POST </strong>para cambiar su estado<strong>.</strong> En la línea 257, se define la función para manejar un requerimiento <strong>POST</strong>, <code>ProcessPostRequest</code>. Es similar al <strong>GET</strong>, pero en este caso se actualiza la propiedad <strong>value</strong>  con el valor recibido en el requerimiento, y se usa la función de <strong>MRAA </strong>para encender el <strong>LED</strong>, enviando un booleano (1: HIGH, 0: LOW) al pin GPIO (23) y al final se crea el payload con el valor actualizado.</p>
<p><strong>examples/OCFSecure/server.cpp </strong></p>
<pre><code>OCEntityHandlerResult
ProcessPostRequest(OCEntityHandlerRequest *ehRequest,
                       OCRepPayload **payload)
{
        OCEntityHandlerResult eh_res = OC_EH_ERROR;
        
        // casting the request payload into a OCRepPayload data type to
        // read the value property
        const OCRepPayload* requestPayload = (OCRepPayload*)(ehRequest-&gt;payload);
        bool value;
        if (OCRepPayloadGetPropBool(requestPayload, &#34;value&#34;, &amp;value))
        {
            SWITCH.value = value;
     #ifdef WITH_MRAA
            GPIO-&gt;write(value);
     #endif
        }
        else
        {
            return eh_res;
        }

        OCRepPayload *ResponsePayload = CreateResponsePayload(SWITCH);

        if (ResponsePayload)
        {
            *payload = ResponsePayload;
            eh_res = OC_EH_OK;
        }

        return eh_res;
}</code></pre>
<p>6.5 En la línea 340, se encuentra un extracto de la función <code>OCEntityHandlerCallBack</code> que es un callback que se registrará al registrar el recurso en IoTivity. Esta función sirve para definir las métodos soportadas por el recurso, en nuestro caso GET y POST, y podemos apreciar que se usan las funciones anteriormente descritas para manejar esos requerimientos.</p>
<p><strong>examples/OCFSecure/server.cpp   : OCEntityHandlerCallBack</strong></p>
<pre><code>if (OC_REST_GET == requestMethod)
{
    eh_res = ProcessGetRequest(&amp;payload);
}
else if (OC_REST_POST == requestMethod)
{
     eh_res = ProcessPostRequest(ehRequest, &amp;payload);
}
else
{
     eh_res = OC_EH_ERROR;
} </code></pre>
<p>6.6 En la línea 360, más abajo en la misma función <code>OCEntityHandlerCallBack</code>, se obtiene el payload creado en el manejo de POST o GET, y se lo envía como respuesta al cliente por medio de <code>OCDoResponse</code>. La información necesaria se obtiene del requerimiento recibido inicialmente.</p>
<p><strong>examples/OCFSecure/server.cpp  : OCEntityHandlerCallBack</strong></p>
<pre><code>if (eh_res == OC_EH_OK)
{
   ehResponse.requestHandle = ehRequest-&gt;requestHandle;
   ehResponse.resourceHandle = ehRequest-&gt;resource;
   ehResponse.ehResult = eh_res;
   ehResponse.payload = (OCPayload*)(payload);
   ehResponse.numSendVendorSpecificHeaderOptions = 0;
   memset(ehResponse.sendVendorSpecificHeaderOptions, 0,
   sizeof(ehResponse.sendVendorSpecificHeaderOptions));
   memset(ehResponse.resourceUri,
      0,
      sizeof(ehResponse.resourceUri));
   ehResponse.persistentBufferFlag = 0;

   // Send the ehResponse
   stackResult = OCDoResponse(&amp;ehResponse);
   i{f (stackResult != OC_STACK_OK)
   {
        eh_res = OC_EH_ERROR;
   }
}
else
{</code></pre>
<p>6.7 El <code>main()</code> es el punto de inicio de nuestro programa C++, por lo tanto en él vamos a definir los recursos a exponer por el servidor y el loop de procesamiento de IoTivity.</p>
<p>Dentro del <code>main()</code>, en la línea 465, se encuentra la parte encargada de definir el pin del LED (foquito). Este pin podrá ser usado por medio de la variable <code>GPIO</code>.</p>
<aside class="special"><p><code>LED_PIN</code> no está definida en <strong>server.cpp</strong>, pero se encuentra en el <strong>SConscript</strong> y se agrega al compilar con scons. Dicho archivo fue actualizado en el paso anterior.</p>
</aside>
<p><strong>examples/OCFSecure/server.cpp   : main()</strong></p>
<pre><code>#if defined(WITH_MRAA) 
#if defined(RAW_GPIO)
GPIO = new mraa::Gpio(LED_PIN, true, true);
#else
GPIO = new mraa::Gpio(LED_PIN);
#endif

GPIO-&gt;dir(mraa::DIR_OUT);
#endif</code></pre>
<p>6.8 En la línea 465, se usa <code>OCRegisterPersistentStorageHandler(),</code> necesaria para la seguridad porque define un método para acceder a archivos como la base de datos de seguridad oic_db_server.dat o switch_introspection.dat</p>
<p><strong>examples/OCFSecure/server.cpp    : main()</strong></p>
<pre><code>OCPersistentStorage ps = {ServerFOpen, fread, fwrite, fclose, unlink};
OCRegisterPersistentStorageHandler(&amp;ps);
</code></pre>
<p>Para iniciar IoTivity hay tres modos:</p>
<ul>
<li>Cliente:  <code>iotivity.OCMode.OC_CLIENT</code></li>
<li>Servidor:  <code>iotivity.OCMode.OC_SERVER</code></li>
<li>Cliente y servidor: <code>iotivity.OCMode.OC_CLIENT_SERVER</code></li>
</ul>
<p>Para iniciar un cliente seguro se debe usar </p>
<pre><code>OC_CLIENT_SERVER </code></pre>
<p>debido a un bug del cliente al momento de cargar la base de datos.</p>
<p>6.9 Usamos la siguiente función para iniciar IoTivity:</p>
<p><strong>examples/OCFSecure/server.cpp   : main</strong></p>
<pre><code>stack_res = OCInit(NULL, 0, OC_SERVER);</code></pre>
<p>6.10 En la línea 479, se registra el interruptor del foquito como recurso de IoTivity, para lo cual se coloca el <strong>tipo</strong>, <strong>interfaz</strong>, <strong>uri</strong> y <strong>propiedades</strong> los cuales fueron definidos en la estructura <code>BinarySwitch</code> que fue instanciada como una variable global llamada <code>SWITCH</code>. También se coloca el <code>OCEntityHandlerCallBack</code> para manejar las peticiones solicitadas al uri (/switch) del recurso.</p>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80" target="_blank"><strong>examples/OCFSecure/</strong></a><strong>server.cpp   : main</strong></p>
<pre><code>{{stack_res = OCCreateResource(&amp;(SWITCH.handle),
                                     SWITCH.type,
                                     SWITCH.interface,
                                     SWITCH.uri,
                                     OCEntityHandlerCallBack,
                                     NULL,
SWITCH.properties);</code></pre>
<p>6.11 En la línea 542,  se define el <strong>loop</strong> del programa, que se encarga de llamar a <code>OCProcess</code> para procesar las peticiones y ejecutar el respectivo callback según el recurso.</p>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80" target="_blank"><strong>examples/OCFSecure/</strong></a><strong>server.cpp   : main</strong></p>
<pre><code>while (!STOP)
{
            stack_res = OCProcess();
     
     nanosleep(&amp;timeout, NULL);
}</code></pre>
<aside class="special"><p><strong>Endpoint</strong></p>
<p>Un Endpoint (OCF) está definido como el destino o fuente de una petición y responde mensajes para un conjunto de protocolos de transporte (Ej: CoAO sobre UDP sobre IPv6). </p>
<p>Para CoAP/UDP/IPv6, el Endpoint está identificado como: dirección IP + puerto. Ej: coap://[fe80::b1d6]:44444</p>
<p>Al usar IoTivity hay que verificar que use el endpoint seguro si se quiere comunicar con seguridad. El seguro es <strong>coaps</strong>:</p>
<p>eps&#34;: [{&#34;ep&#34;: &#34;coap://[fe80::b1d6]:44444&#34;}, {&#34;ep&#34;: &#34;coaps://[fe80::b1d6]:11111&#34;} ] }</p>
</aside>
<p>6.12 Los archivos construidos se generan en <code>/out/&lt;os&gt;/&lt;architecture&gt;/&lt;debug/release&gt;</code> y luego la ruta mostrada en el directorio raíz de IoTivity  en nuestro caso <code>/examples/OCFSecure/</code></p>
<p>6.13 Ejecutar lo siguiente en un terminal, para probar que el foquito funciona:</p>
<pre><code>$ ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure/server</code></pre>
<p><strong>Posible error:</strong></p>
<pre><code>pi@raspberrypi:~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure 
$ ./server
./server: error while loading shared libraries: libmraa.so.2: cannot open shared object file: No such file or directory</code></pre>
<p><strong>Solución:</strong></p>
<pre><code>$ cd /usr/lib
$ ls </code></pre>
<p>Si está la librería libmraa.so.2:</p>
<pre><code>$ cd ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure
$ export LD_LIBRARY_PATH=&#34;/usr/lib&#34;
$ sudo ldconfig
$ ./server
</code></pre>
<p>Si no está la librería libmraa.so.2 en /usr/lib:</p>
<pre><code>$ sudo find / -name libmraa.so.2</code></pre>
<p>y usar el path que le entregue como </p>
<pre><code>LD_LIBRARY_PATH</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: Agregar el método OBSERVE (Raspberry Pi)" duration="11">
        <p>Los dispositivos IoTivity pueden indicar a otros dispositivos que quieren ser notificados de su estado cuando les suceda un cambio. Para ello, hay que declarar el método <strong>OBSERVE</strong> agregando las siguientes partes de código:</p>
<p>En el paso anterior, compilamos y ejecutamos un ejemplo prefabricado.</p>
<p>7.1 Para crear nuestros propios dispositivos debemos declararlos en el <strong>SConscript</strong>, en este ejemplo nuestra luz se llamará <strong>light</strong>. Ya que està basado en el ejemplo anterior, vamos a copiar ese archivo y usarlo como plantilla, se llamará <strong>light.cpp</strong>:</p>
<pre><code>$ cd examples/OCFSecure
$ cp server.cpp light.cpp
$ nano SConscript</code></pre>
<p>7.2 Declaramos el nuevo archivo en el SConscript:</p>
<p><code>light = samples_env.Program(&#39;light&#39;, [light.cpp&#39;])</code></p>
<p>Y a su vez lo agregamos a la lista de <strong>targets</strong> a ser construidos:</p>
<p><code>list_of_samples = [client, client_dat, client_dev, server, server_dat, light]</code></p>
<p>7.3 Cambiar <code>&#39;LED_PIN=7&#39;</code> por <code>&#39;LED_PIN=23&#39;</code> :</p>
<p><code>cpp_defines.append(&#39;LED_PIN=23&#39;)</code></p>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80" target="_blank"><strong>examples/OCFSecure/SConscript</strong></a></p>
<pre><code>if env.get(&#39;SECURED&#39;) == &#39;1&#39;:
   samples_env.AppendUnique(LIBS=[&#39;mbedtls&#39;, &#39;mbedx509&#39;, &#39;mbedcrypto&#39;, &#39;wiringPi&#39;])

introspection_dat = samples_env.Install(
        build_dir + examples_dir, src_dir + examples_dir + &#39;switch_introspection.dat&#39;)
light = samples_env.Program(&#39;light&#39;, [&#39;light.cpp&#39;])

list_of_samples = [client, client_dat, client_dev, server, server_dat, light]

Alias(&#34;secureExamples&#34;, list_of_samples)</code></pre>
<p>7.4 Ahora procederemos a editar el archivo <code>light.cpp</code>:</p>
<pre><code>$ nano light.cpp</code></pre>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80" target="_blank"><strong>iotivity</strong></a><strong>/</strong><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80/examples" target="_blank"><strong>examples</strong></a><strong>/</strong><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80/examples/OCFSecure" target="_blank"><strong>OCFSecure</strong></a><strong>/light.cpp</strong></p>
<p>7.5. Agregar esta línea al inicio del documento en la declaración de librerías:</p>
<pre><code>#include &lt;stdio.h&gt;</code></pre>
<p>7.6. Agregar las siguientes constantes y variables,:</p>
<pre><code>// Define el número máximo de observers
#define SAMPLE_MAX_NUM_OBSERVATIONS 8 

// Bandera a ser usada en el loop de observación
int gLightUnderObservation = 0; </code></pre>
<p>7.7. Para que pueda ser observado, el dispositivo debe contar con la propiedad <code>OC_OBSERVABLE</code> que le informa al descubridor de que el dispositivo encontrado puede ser observado. Para esto hay que modificar la estructura <code>binarySwitch</code>, agregando <code>OC_OBSERVABLE</code> a sus propiedades (properties): </p>
<pre><code>uint8_t properties = OC_DISCOVERABLE | OC_SECURE | OC_OBSERVABLE; </code></pre>
<p>Agregar tambien esta variable:</p>
<pre><code>bool lastValue = false;</code></pre>
<p>7.8. Definimos una estructura llamada <strong>Observers</strong> que mantendrá información del observer como su <strong>ID</strong>, la <strong>función</strong> a ejecutarse cuando se solicite una observación (<code>resourceHandle</code>) y una bandera para saber si es <strong>válido</strong>:</p>
<pre><code>/* Structure to represent the observers */
typedef struct
{
        OCObservationId observationId;
        bool valid;
        OCResourceHandle resourceHandle;
} Observers;</code></pre>
<p>7.9. Cada vez que se reciba una petición de observer, se creará un <strong>Observer</strong> con la estructura anteriormente definida. Estos <strong>Observers </strong>serán almacenados en el siguiente arreglo: </p>
<pre><code>/* Lista de observers registrados */
Observers interestedObservers[SAMPLE_MAX_NUM_OBSERVATIONS];</code></pre>
<p>7.10. Añadimos la función encargada de procesar la petición <code>REGISTER OBSERVE</code>. Esta función se encarga de sacar un observer de <code>interestedObservers</code>, colocarle los datos a un observer inválido y volverlo válido: </p>
<pre><code>/* Función a ejecutar cuando se registra un nuevo observer*/
void ProcessObserveRegister (OCEntityHandlerRequest *ehRequest)
{
        OIC_LOG_V(DEBUG, TAG, &#34;Received observation registration request with observation Id [%i]&#34;, ehRequest-&gt;obsInfo.obsId);
        for (uint8_t i = 0; i &lt; SAMPLE_MAX_NUM_OBSERVATIONS; i++)
        {
            if (interestedObservers[i].valid == false)
            {
                interestedObservers[i].observationId = ehRequest-&gt;obsInfo.obsId;
                interestedObservers[i].valid = true;
                gLightUnderObservation = 1;
                break;
            }
        }
}</code></pre>
<p>7.11. Añadimos la función encargada de deregistrar los observers cuando se recibe la petición de <code>DEREGISTER OBSERVE</code>. Lo que hace es cambiar la bandera valid de válido a inválido del observer indicado. Si ya no hay ningún observer observando, <code>gLightUnderObservation</code> quedará en falso, lo que impedirá que la función <code>ChangeSwitchRepresentation</code> notifique a los observers: </p>
<pre><code>/* Función a ejecutar cuando se deregistra el observer*/
void ProcessObserveDeregister (OCEntityHandlerRequest *ehRequest)
{
        bool clientStillObserving = false;
        OIC_LOG_V(DEBUG, TAG, &#34;Received observation deregistration request for observation Id  [%i]&#34;, ehRequest-&gt;obsInfo.obsId);
        for (uint8_t i = 0; i &lt; SAMPLE_MAX_NUM_OBSERVATIONS; i++)
        {
            if (interestedObservers[i].observationId == ehRequest-&gt;obsInfo.obsId)
            {
                interestedObservers[i].valid = false;
            }
            if (interestedObservers[i].valid == true)
            {
                // Even if there is one single client observing we continue notifying entity handler
                clientStillObserving = true;
            }
        }
        if (clientStillObserving == false)
            gLightUnderObservation = 0;
}</code></pre>
<p>7.12. Dentro de la función <code>OCEntityHandlerCallback</code> manejamos el evento de recibir una petición de <code>OBSERVE</code>, llamando a la función correcta de acuerdo a si la acción es <strong>register</strong> o <strong>deregister observer</strong>: </p>
<pre><code>/* Colocar dentro del OCEntityHandlerCallback*/
        if (flag &amp; OC_OBSERVE_FLAG)
        {
            OIC_LOG_V(INFO, TAG, &#34;Flag includes OC_OBSERVE_FLAG&#34;);

            if (OC_OBSERVE_REGISTER == ehRequest-&gt;obsInfo.action)
            {
                OIC_LOG_V(INFO, TAG,&#34;Received OC_OBSERVE_REGISTER from client&#34;);
                ProcessObserveRegister (ehRequest);
            }
            else if (OC_OBSERVE_DEREGISTER == ehRequest-&gt;obsInfo.action)
            {
                OIC_LOG_V(INFO, TAG,&#34;Received OC_OBSERVE_DEREGISTER from client&#34;);
                ProcessObserveDeregister (ehRequest);
            }
        }

</code></pre>
<p>7.13. Agregamos la función <code>ChangeSwitchRepresentation</code> que será ejecutada en un thread y se encargará de notificar a los observers cuando haya un cambio en la luz:</p>
<pre><code>/* Función a ser usada en la creación de un thread para observar*/ 
void *ChangeSwitchRepresentation (void *param)
{
        (void)param;
        OCStackResult result = OC_STACK_ERROR;

        //uint8_t numNotifies = (SAMPLE_MAX_NUM_OBSERVATIONS)/2;//OCObservationId obsNotify[numNotifies];

        while (!STOP)
        {
            sleep(3);
            if (SWITCH.value != SWITCH.lastValue){
                if (gLightUnderObservation)
                {
                    OIC_LOG_V(INFO, TAG, &#34;=====&gt; Notifying stack of new switch state: [%i]&#34;,SWITCH.value);
                    // Notifying all observers
                    result = OCNotifyAllObservers (SWITCH.handle, OC_NA_QOS);
                    SWITCH.lastValue = SWITCH.value;
                    if (OC_STACK_NO_OBSERVERS == result)
                    {
                        OIC_LOG_V(ERROR, TAG,&#34;=====&gt; No more observers exist, stop sending observations&#34;);
                        gLightUnderObservation = 0;
                    }
                }                
            }
        }
        return NULL;
}
</code></pre>
<p>7.14. Dentro de la función <code>main()</code> (al final del archivo) colocamos :</p>
<pre><code>/*
* Esto va al principio del main, donde se declaran las variables
*/
pthread_t threadId;

.
.
.

/*
* Esto va después del mensaje: &#34;Server is running&#34;
*/
// Initialize observations data structure for the resource
for (uint8_t i = 0; i &lt; SAMPLE_MAX_NUM_OBSERVATIONS; i++)
{
    interestedObservers[i].valid = false;
}

//Create a thread for changing the representation of the Light
pthread_create (&amp;threadId, NULL, ChangeSwitchRepresentation, (void *)NULL);

.
.
.

/*
*  Esto va antes del mensaje: &#34;Stopping IoTivity server&#34;
*/
// Cancel the Light thread and wait for it to terminate
pthread_cancel(threadId);
pthread_join(threadId, NULL);</code></pre>
<p>7.15. Compilar:</p>
<pre><code>$ scons examples/OCFSecure -j 2 TARGET_TRANSPORT=IP
scons: done building targets.</code></pre>
<p>7.16. Probarlo:</p>
<pre><code>$ ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure/light</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Asegurando los dispositivos inteligentes" duration="40">
        <p>Iotivity busca ser seguro, por lo cual define varios pasos para serlo.</p>
<p>El primero es <strong>onboarding</strong>, en el que se establece quién es el dueño del dispositivo. Por lo general es llamado transferencia de dueño, siendo el dueño original el fabricante y el dueño actual el usuario que lo compro. </p>
<p>Una vez establecido el dueño, se procede al <strong>provisioning</strong>. El provisioning es un paso en el que se provisiona al dispositivo con la información necesaria para ser usado. Entre esta información se encuentran los access control entries (ACEs) que son recursos ubicados en el access control list (<code>aclist2</code>), que definen los permisos de acceso a los recursos. Cada ACE puede dar permisos por tipo de conexión (<code>conntype</code>), rol, o por un dispositivo en específico (<code>UUID</code>). Si es por <code>conntype</code>, esta puede ser anónima y sin encriptar (<code>anon-clear</code>) o autenticada y encriptada (<code>auth-crypt</code>). Para poder conectarse de manera autenticada, se debe poseer una forma de verificar la identidad, por ejemplo las claves compartidas. </p>
<p>A continuación se muestra un típico ACE, que contiene recursos accesibles por cualquier dispositivo, <code>/oic/res</code> debe serlo para que sus recursos sean descubiertos. Al final se define el permiso (<code>permission</code>), CRUDN como un valor binario del 0 al 32: C(1) + R(2)+U(4)+D(8)+ N(16), Por ende los recursos de abajo solo permiten ser leídos (RETRIEVE: 2).</p>
<pre><code>&#34;acl&#34;: {
            &#34;aclist2&#34;: [
                {
                    &#34;aceid&#34;: 1,
                    &#34;subject&#34;: { &#34;conntype&#34;: &#34;anon-clear&#34; },
                    &#34;resources&#34;: [
                        { &#34;href&#34;: &#34;/oic/res&#34; },
                        { &#34;href&#34;: &#34;/oic/d&#34; },
                        { &#34;href&#34;: &#34;/oic/p&#34; }
                    ],
                    &#34;permission&#34;: 2
                },</code></pre>
<p>Vamos a compilar unas herramientas para editar archivos de seguridad. Para ello ejecutamos en un terminal lo siguiente:</p>
<pre><code>$ cd ~/iot/iotivity/
$ scons resource/csdk/security -j 2 TARGET_TRANSPORT=IP</code></pre>
<p>Podemos verificar los permisos de nuestra luz por medio de la herramienta <code>svrdbeditor</code>. Los archivos de seguridad se guardan en formato <strong>cbor</strong> con extensión de archivo <strong>.dat</strong>.</p>
<aside class="special"><p><strong>Uso: </strong><code>svrdbeditor ocf_svr_db_server.dat </code></p>
</aside>
<pre><code>$ ~/iot/iotivity/out/linux/armv7l/release/resource/csdk/security/tool/svrdbeditor ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure/ocf_svr_db_server.dat </code></pre>
<p>También se pueden generar los archivos de seguridad<strong> .dat</strong> a partir de un archivo<strong>.json</strong>, usando la herramienta<strong> json2cbor</strong>:</p>
<aside class="special"><p><strong>Uso: </strong><code>json2cbor input.json output.dat </code></p>
</aside>
<pre><code>$ ~/iot/iotivity/out/linux/armv7l/release/resource/csdk/security/tool/json2cbor ~/iot/iotivity/examples/OCFSecure/ocf_svr_db_server_RFOTM.json ocf_svr_db_server.dat</code></pre>
<p>Si se quiere resetear el estado del dispositivo para hacerle onboarding, se puede usar el archivo RFOTM:</p>
<ul>
<li>Ready For Ownership Transfer Method (RFOTM): <code>ocf_svr_db_server_RFOTM.dat</code></li>
</ul>
<p>El archivo RFNOP, es de un dispositivo ya provisionado: </p>
<ul>
<li>Ready For Normal Operation (RFNOP): <code>ocf_svr_db_server_RFNOP.dat</code> </li>
</ul>
<pre><code>$ cp ~/iot/iotivity/examples/OCFSecure/ocf_svr_db_server_RFOTM.dat ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure/ocf_svr_db_server.dat
$ rm ~/iot/iotivity/out/linux/armv7l/release/examples/OCFSecure/switch_introspection.dat </code></pre>
<p>De vuelta a nuestro ejemplo:</p>
<p>Inspeccionando el archivo <code>oic_svr_db.json</code>, podemos ver que cuenta con credenciales. Posee una credencial por cada dispositivo con el que se puede conectar de forma segura. La credencial contiene el UUID del dispositivo dueño de la credencial, los datos y la codificación:</p>
<pre><code> &#34;cred&#34;:{
            &#34;creds&#34;: [
                {
                    &#34;credid&#34;: 1,
                    &#34;subjectuuid&#34;: &#34;12345678-1234-1234-1234-123456789012&#34;,
                    &#34;credtype&#34;: 1,
                    &#34;privatedata&#34;:{
                        &#34;data&#34;:&#34;AAAAAAAAAAAAAAAA&#34;,
                        &#34;encoding&#34;: &#34;oic.sec.encoding.raw&#34;
                    }
                }],
            &#34;rowneruuid&#34;: &#34;32323232-3232-3232-3232-323232323232&#34;
}</code></pre>
<p><code>Ready for provisioning:</code></p>
<pre><code>        &#34;pstat&#34;: {
            &#34;dos&#34;: { &#34;s&#34;: 1, &#34;p&#34;: false },
            &#34;isop&#34;: false,
            &#34;cm&#34;: 2,
            &#34;tm&#34;: 0,
            &#34;om&#34;: 4,
            &#34;sm&#34;: 4,
            &#34;rowneruuid&#34;: &#34;&#34;
        },
        &#34;doxm&#34;: {
            &#34;oxms&#34;: [0],
            &#34;oxmsel&#34;: 0,
            &#34;sct&#34;: 1,
            &#34;owned&#34;: false,
            &#34;deviceuuid&#34;: &#34;00000000-0000-0000-0000-000000000000&#34;,
            &#34;devowneruuid&#34;: &#34;&#34;,
            &#34;rowneruuid&#34;: &#34;&#34;
        }
}</code></pre>
<p><code>Provisioned:</code></p>
<pre><code>&#34;pstat&#34;: {
            &#34;dos&#34;: { &#34;s&#34;: 3, &#34;p&#34;: false },
            &#34;isop&#34;: true,
            &#34;cm&#34;: 0,
            &#34;tm&#34;: 0,
            &#34;om&#34;: 4,
            &#34;sm&#34;: 4,
            &#34;rowneruuid&#34;: &#34;32323232-3232-3232-3232-323232323232&#34;
},
&#34;doxm&#34;: {
            &#34;oxms&#34;: [0],
            &#34;oxmsel&#34;: 0,
            &#34;sct&#34;: 1,
            &#34;owned&#34;: true,
            &#34;deviceuuid&#34;: &#34;32323232-3232-3232-3232-323232323232&#34;,
            &#34;devowneruuid&#34;: &#34;32323232-3232-3232-3232-323232323232&#34;,
            &#34;rowneruuid&#34;: &#34;32323232-3232-3232-3232-323232323232&#34;
},</code></pre>
<pre><code>sct:</code></pre>
<p>supported credential type</p>
<p>Hay otras formas de hacer provisioning:</p>
<aside class="special"><p>Instalar aplicaciones de Android mediante APKs de terceros:</p>
<ol type="1" start="1">
<li>Ir a <strong>Settings &gt; Security</strong>.</li>
<li>Bajar y <em>seleccionar </em><strong><em>&#34;Unknown sources&#34;</em></strong><em> chechbox.</em></li>
<li>Tap <strong>OK cuando aparezca una advertencia</strong>. Listo, ahora puede instalar aplicaciones de terceros (APKs) en su dispositivo con Android 4.0+.</li>
<li><a href="https://git-scm.com/downloads" target="_blank"><paper-button class="colored" raised>Descargar apk</paper-button></a></li>
<li>Ejecutar apk descargada, mediante una notificación o buscar en downloads y seleccionarla.</li>
</ol>
</aside>
<h2><strong>Onboarding Tool Generic Client (OTGC) </strong></h2>
<p>(<a href="https://github.com/openconnectivityfoundation/development-support/tree/master/otgc" target="_blank"><code>https://github.com/openconnectivityfoundation/development-support/tree/master/otgc</code></a><code>)</code></p>
<p>Es una aplicación que funciona como aprovisionador y cliente genérico para hacer debugging.</p>
<h3><strong>Windows</strong></h3>
<p>Descargar e instalar Device Spy (Doble clic o enter al archivo descargado):</p>
<p><a href="https://openconnectivityfoundation.github.io/development-support/DeviceSpy/OCFDeviceSpy_1.0/OCFDeviceSpySetup.msi" target="_blank"><paper-button class="colored" raised>Descargar DeviceSpy</paper-button></a></p>
<h3><strong>Android (5.0.1+)</strong></h3>
<p>Descargar e instalar OTGC (pasos de instalación arriba):</p>
<p><a href="https://github.com/openconnectivityfoundation/development-support/raw/master/otgc/android/otgc-debug.apk" target="_blank"><paper-button class="colored" raised>Descargar OTGC</paper-button></a></p>
<h3><strong>Linux</strong></h3>
<p>Ejecutar el siguiente comando en un terminal:</p>
<pre><code>$ curl https://openconnectivityfoundation.github.io/development-support/otgc/linux/install.sh | bash</code></pre>
<h2><strong>Linux Iotivity provisioner</strong></h2>
<p><a href="https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80/resource/provisioning" target="_blank">https://github.com/iotivity/iotivity/tree/cabc8d2e24ac1a406f9f70d3fcd066c5daedad80/resource/provisioning</a></p>
<p>Compilar el proyecto de IoTivity, y dentro de los resultados en la carpeta out/ se encuentra el provisioning client:</p>
<pre><code>$ cd iotivity &amp;&amp; scons resource/provisioning -j 2
$ ~/iot/iotivity/out/linux/x86_64/release/resource/provisioning/examples/provisioningclient</code></pre>
<p>Copiar el <code>oic_svr_db_client.dat</code> a la carpeta donde se ejecuta el programa, puede ser: </p>
<p><code>/iotivity/out/linux/armv7l/release/examples/OCFSecure/</code></p>
<p><strong>Provisioning manualmente</strong></p>
<p>Hay dos alternativas:</p>
<ul>
<li><strong>json2cbor tool:</strong> Crear un archivo <code>.json</code> indicando los ACLs, credenciales y estado del aprovisionamiento y convertirlo a archivo .dat mediante la herramienta <code>json2cbor</code> localizada en <code>iotivity/out/linux/armv7l/release/examples/OCFSecure/</code></li>
<li><strong>cbor editor: </strong>Aprovisionar con un cliente genérico y editar las claves de cada dispositivo para que se puedan comunicar entre sí.</li>
</ul>
<h2><strong>Android Smart Home Demo </strong></h2>
<p>(<a href="https://git.cti.espol.edu.ec/labproto/ariotivity-provisioner.git" target="_blank"><code>https://git.cti.espol.edu.ec/labproto/ariotivity-provisioner.git</code></a>) Esta aplicación fue usada inicialmente para hacer provisioning, pero fue descontinuada y ya no existe su repositorio en Github. Se instala descargando el apk y siguiendo los pasos de arriba.</p>
<aside class="special"><p>Pasos para habilitar la seguridad: <a href="https://wiki.iotivity.org/steps_for_enabling_security_in_iotivity_applications" target="_blank">https://wiki.iotivity.org/steps_for_enabling_security_in_iotivity_applications</a></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: IoTivity &#43; node.js (Ubuntu)" duration="0">
        <p>Una de las ventajas de IoTivity es que es multiplataforma, facilitandonos el uso desde servidores hasta dispositivos con recursos limitados como un ESP32Thing. También cuenta con bindings para algunos lenguajes como lo son C, C++, Java, Node.js. Para crear nuestro interruptor virtual vamos a hacer uso de <code>iotivity-node,</code>que es IoTivity en Node.js (Javascript).</p>
<p>Para instalar  <code>node</code>, vamos a hacer uso de un manejador de versiones de Node.js, para lo cual hay que ejecutar el siguiente comando para instalarlo:</p>
<pre><code>$ curl https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</code></pre>
<p>Cerrar y abrir el terminal para usar nvm. Instalar la versión <code>lts/dubnium</code> de <code>node.js</code> por medio de <code>nvm</code>:</p>
<pre><code>$ nvm install lts/dubnium</code></pre>
<p>Instalar <code>iotivity-node</code>:</p>
<pre><code>$ npm i iotivity-node</code></pre>
<p>Al final, se muestran unos <code>warn</code>, no se preocupen.</p>
<aside class="special"><h2>Instalación alternativa:</h2>
<p><code>$ git clone https://github.com/intel/iotivity-node.git</code></p>
<p><code>$ cd ~/iotivity-node</code></p>
<p><code>$ npm install </code></p>
<p>Si da error, instalar manualmente <code>node-gyp</code> y volver a intentar con <code>npm install</code>:</p>
<p><code>$ npm install -g node-gyp</code></p>
<p>Si da error, verificar version de node.</p>
</aside>
<p>Para ejecutar un ejemplo sencillo y comprobar su correcta instalación nos cambiamos al directorio ~/node_modules/iotivity-node/js y ejecutamos un server:</p>
<pre><code>$ cd ~/node_modules/iotivity-node/js
$ node server.get.js
Starting OCF stack in server mode
Registering resource
Server ready</code></pre>
<p>No es necesario instalar el repositorio de iotivity cuando vamos a usar iotivity-node, pero a veces es útil tenerlo para usar sus herramientas.</p>
<aside class="special"><h2><strong>Información adicional:</strong></h2>
<ul>
<li>Iotivity-node npm page: <a href="https://www.npmjs.com/package/iotivity-node" target="_blank">https://www.npmjs.com/package/iotivity-node</a>        </li>
<li>Iotivity en node.js con Raspberry Pi: https://openconnectivity.org/wp-content/uploads/2017/12/Nodejs_IoTivity_Light_on_Raspberry_Pi.pdf</li>
</ul>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: Crear el interruptor (Ubuntu)" duration="0">
        <p><strong>Instalar nw.js</strong></p>
<p>Usamos nwjs para ejecutar una aplicación de nodejs como una aplicación de escritorio.</p>
<pre><code>$ npm i -g nwjs # no funciona, no usar
$ cd ~
$ wget -qO- nwjs.zip https://dl.nwjs.io/v0.35.4/nwjs-sdk-v0.35.4-linux-x64.tar.gz | tar xvz</code></pre>
<p>Creamos el archivo interruptor.js y lo editamos en <code>nano</code>:</p>
<pre><code>$ cd ~
$ mkdir iot
$ nano interruptor.js</code></pre>
<p>Declaramos variables especificas a iotivity:</p>
<ul>
<li><code>ocf</code>: carga el paquete de iotivity.</li>
<li><code>client</code>: instancia un cliente de iotivity.</li>
</ul>
<h3>interruptor.js</h3>
<pre><code>var ocf = require(&#39;iotivity-node&#39;),
    client = ocf.client;</code></pre>
<h3>Configuramos nuestro cliente para que use la especificación 1.1.0:</h3>
<pre><code>ocf.device = Object.assign(ocf.device, {
    coreSpecVersion: &#39;ocf.1.1.0&#39;,
    dataModels: [&#39;res.1.1.0&#39;]
});</code></pre>
<p>Creamos una variable que va a almacenar la información de recurso de las luces encontradas:</p>
<h3>interruptor.js</h3>
<pre><code>// Stores the resource info of each light switch found
var switchesFound;</code></pre>
<p>Agregamos unas funciones para mostrar información y ayudarnos a ver que sucede.</p>
<h3>interruptor.js</h3>
<pre><code>// The html id of each device is formed by resource.deviceId + &#39;:&#39; + resource.resourcePath;

// Show text in the bottom status bar
function log(string) {
    document.getElementById(&#39;statusBar&#39;).innerHTML = string;
}

function serverError(error) {
    log(&#39;Server return error:&#39;, error.message);
}</code></pre>
<p>Registramos una función que se encargará de agregar las representaciones de la luz en forma de switch a la interfaz gráfica. Al agregar registrar un listener al interruptor, que cuando sea activado actualice el estado en el interruptor de manera remota.</p>
<h3>interruptor.js</h3>
<pre><code>// Add card to UI
function addResourceHolderToUI(resource) {
    var cards = document.getElementById(&#39;resources&#39;),
        node = cards.firstElementChild;
    if (cards.style.display === &#39;none&#39;) {
        cards.style.display = &#39;block&#39;;
    } else {
        node = node.cloneNode(true);
        cards.appendChild(node);
    }
    node.getElementsByClassName(&#39;resourceUUID&#39;)[0].innerHTML = resource.deviceId;
    node.getElementsByClassName(&#39;resourcePath&#39;)[0].innerHTML = resource.resourcePath;
    
    // Register a listener to update (make a post) the resource when activated
    var checkbox = node.getElementsByClassName(&#39;checkbox&#39;)[0];
    checkbox.id = resource.deviceId + &#39;:&#39; + resource.resourcePath;
    checkbox.onclick = function() {
        var resource = switchesFound[this.id];
        resource.properties.value = this.checked;
        client.update(resource);
    }
}</code></pre>
<p>Declaramos la función <code>purgeAllResourceHoldersFromUI</code> que hace lo opuesto a la anterior, eliminar todos los interruptores.</p>
<h3>interruptor.js</h3>
<pre><code>// Delete all switch cards from UI
function purgeAllResourceHoldersFromUI() {
    var cards = document.getElementById(&#39;resources&#39;);
    while (cards.childElementCount &gt; 1)
        cards.removeChild(cards.lastElementChild);
    cards.style.display = &#39;none&#39;;
}
</code></pre>
<p>Agregamos una función que se encarga de eliminar un recurso. Lo elimina de la interfaz gráfica y de la lista de recursos, también elimina sus listeners.</p>
<h3>interruptor.js</h3>
<pre><code>// Delete resource from UI
function deleteResource(resource) {
    var id = this.deviceId + &#39;:&#39; + this.resourcePath;
    log(&#39;deleteResource(&#39; + this.resourcePath + &#39;)&#39;);

    var resource = switchesFound[id];
    if (resource) {
        // Remove listeners associated to the resource to be deleted
        resource.removeListener(&#39;update&#39;, observeResource);
        resource.removeListener(&#39;delete&#39;, deleteResource);
        // Delete resource info
        delete switchesFound[id];

        var child = document.getElementById(id);
        var parent = child.parentElement;
        while (parent.id != &#39;resources&#39;)
            child = parent, parent = parent.parentElement;
        if (parent.childElementCount &gt; 1)
            parent.removeChild(child);
        else {
            // remove from layout instead of from DOM
            parent.style.display = &#39;none&#39;;
        }
    }
}
</code></pre>
<p>Creamos una función para actualizar al interruptor con el valor actual.</p>
<h3>interruptor.js</h3>
<pre><code>// Observe resource
function observeResource(resource) {
    // Validates that the resource has the &#39;value&#39; property
    if ((&#39;properties&#39; in resource) &amp;&amp; (&#39;value&#39; in resource.properties)) {
        var id = resource.deviceId + &#39;:&#39; + resource.resourcePath;
        // Update visual switch with the actual value of the resource
        document.getElementById(id).checked = resource.properties.value;
    }
}</code></pre>
<p>La función <code>discoverBinarySwitch</code> se ejecuta al presionar el botón <strong>Discover</strong>. Lo que hace es eliminar todo y comenzar de cero. Realice una petición multicast en busca del recurso de tipo <code>&#39;oic.r.switch.binary&#39;</code>, cuando alguien le responde ejecuta la función <code>resourceFound</code></p>
<h3>interruptor.js</h3>
<pre><code>// Executed when the discover button is activated
function discoverBinarySwitch() {
    log(&#39;Discovering...&#39;);
    // Start from zero, delete everything
    purgeAllResourceHoldersFromUI();
    switchesFound = {};
    client.on(&#39;error&#39;, serverError)
          .findResources({ &#39;resourceType&#39;: [&#39;oic.r.switch.binary&#39;] }, resourceFound).then(
        function() {
            log(&#39;findResources() successful&#39;);
        },
        function(error) {
            log(&#39;findResources() failed with &#39; + error);
        });
}
</code></pre>
<p>Finalmente, agregamos la función previamente mencionada. Esta función crea un elemento HTML con id resultante de la concatenación del deviceID y path del recurso (deviceID:path). De igual manera se registran los listeners para update y delete.</p>
<h3>interruptor.js</h3>
<pre><code>// Handler to be executed when a resource is found
function resourceFound(resource) {
    log(&#39;Resource found: &#39; + resource.deviceId);
    var id = resource.deviceId + &#39;:&#39; + resource.resourcePath;
    // If it wasn&#39;t previously found, we add it to the switches found and add listeners to it.
    if (!switchesFound[id]) {
        switchesFound[id] = resource;
        resource.addListener(&#39;update&#39;, observeResource);
        resource.addListener(&#39;delete&#39;, deleteResource);
        resource.addListener(&#39;error&#39; , serverError);
        addResourceHolderToUI(resource);
    }
}</code></pre>
<h3><code>Ctrl+x</code> , <code>y</code> y luego <code>Enter</code> para guardar y salir.</h3>
<p>Creamos el archivo y lo editamos en <code>nano</code>:</p>
<pre><code>$ cd ~/iot
$ nano interruptor.js</code></pre>
<h3>En el tag HEAD, añadimos un SCRIPT tag que llame al código javascript del interruptor.  </h3>
<h3>interruptor.html</h3>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;IoTivity Simple Client&lt;/title&gt;
  &lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;styler.css&#34;/&gt;
  &lt;script src=&#34;interruptor.js&#34;&gt;
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div&gt;
    Client UUID: &lt;label id=&#34;uuid&#34;&gt;&lt;/label&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;button onclick=&#34;discoverBinarySwitch()&#34;&gt;Discover&lt;/button&gt;
  &lt;/div&gt;
  &lt;hr&gt;
  &lt;div id=&#34;resources&#34; style=&#34;display: none&#34;&gt;
    &lt;div class=&#34;resourceHolder&#34;&gt;
      &lt;label class=&#34;resourceUUID&#34;&gt;&lt;/label&gt;
      &lt;div&gt;
        &lt;label class=&#34;switch&#34;&gt;
          &lt;input type=&#34;checkbox&#34; class=&#34;checkbox&#34;&gt;&lt;span class=&#34;slider round&#34;&gt;&lt;/span&gt;
        &lt;/label&gt;
        &lt;label class=&#34;resourcePath&#34;&gt;&lt;/label&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;div id=&#34;statusBar&#34;&gt;&lt;/div&gt;
  &lt;script type=&#34;text/javascript&#34;&gt;
    document.getElementById(&#34;uuid&#34;).innerHTML = ocf.device.uuid;
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;</code></pre>
<h3><code>Ctrl+x</code> , <code>y</code> y luego <code>Enter</code> para guardar y salir.</h3>
<h3>Creamos un <code>package.json</code> para indicar el punto de entrada de nuestra aplicación de escritorio.<strong>  </strong></h3>
<pre><code>$ cd ~/iot
$ nano package.json</code></pre>
<h3>package.json</h3>
<pre><code>{
  &#34;name&#34;: &#34;interruptor&#34;,
  &#34;main&#34;: &#34;interruptor.html&#34;
}</code></pre>
<h3><code>Ctrl+x</code> , <code>y</code> y luego <code>Enter</code> para guardar y salir.</h3>
<p><code>Hora de probarlo:</code></p>
<pre><code>$ ~/nwjs-sdk-v0.35.4-linux-x64/nw .</code></pre>
<aside class="special"><p>Si hay algun error: revisar la consola o F12</p>
</aside>
<p>La luz representada como un interruptor aparece en la interfaz gráfica, pero al activarla no sucede nada con el foquito, dado que no contiene las claves compartidas. Pero puede activar dispositivos no seguros como por ejemplo el smart plug. </p>


      </google-codelab-step>
    
      <google-codelab-step label="Recursos extras" duration="0">
        <p>Información sobre iotivity con Raspberry Pi: </p>
<p><a href="https://openconnectivity.org/developer/developer-kit" target="_blank">https://openconnectivity.org/developer/developer-kit</a></p>
<p>Videos de OCF Developer training: </p>
<p><a href="https://www.youtube.com/watch?v=Ug6yUpVU2VM&list=PLz9Us2KgBfxBB1EBtjHdkrMM16ynCykLA" target="_blank">https://www.youtube.com/watch?v=Ug6yUpVU2VM&amp;list=PLz9Us2KgBfxBB1EBtjHdkrMM16ynCykLA</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: IoTivity &#43; node-red" duration="0">
        <p>Instalar <code>node-red</code>:</p>
<pre><code>$ npm -g install node-red
$ node-red
17:03:57 - [info] Server now running at http://127.0.0.1:1880/</code></pre>
<p>Instalar <code>iotivity-node</code> localmente en <code>node-red</code> para poder usarlo:</p>
<pre><code>$ cd ~/.node-red/node_modules
$ git clone https://github.com/otcshare/iotivity-node
$ cd iotivity-node
$ npm install</code></pre>
<p>Edit <code>settings.js</code> file:</p>
<pre><code>$ sudo find / -name &#34;settings.js&#34;
$ vi ~/.node-red/settings.js </code></pre>
<p>Insertar la siguiente línea dentro de la función <code>functionGlobalContext</code>:</p>
<h3><strong>Settings.js</strong></h3>
<pre><code>functionGlobalContext: {
      iotivity:require(&#34;iotivity-node/lowlevel&#34;)
},</code></pre>
<p>Ejecutar <code>node-red</code>:</p>
<pre><code>$ node-red</code></pre>
<p>Para escribir funciones en <code>node-red</code> que usen <code>Iotivity</code>, hay que usar <code>global.get,</code> en <code>node.js</code> puro se hace como en la línea comentada:</p>
<pre><code>//iotivity = require( &#34;iotivity-node/lowlevel&#34; );
iotivity = global.get(&#39;iotivity&#39;);</code></pre>
<p>Para mostrar mensajes en <code>node-red</code> usamos la función <code>node.log</code>:</p>
<pre><code>node.log( &#34;Starting OCF stack in client mode&#34; );</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Bonus: IoTivity Lite" duration="0">
        

      </google-codelab-step>
    
      <google-codelab-step label="Bonus: IoTivity Cloud" duration="0">
        

      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
